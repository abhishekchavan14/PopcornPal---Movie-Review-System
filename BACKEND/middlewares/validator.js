const { check, validationResult } = require('express-validator')
//The check function is used to specify validation and sanitation rules for incoming data.
//The validationResult function is used to extract the validation errors generated by the check function.


//defining the checks to be done
exports.userValidator = [
    check("username").trim().not().isEmpty().withMessage("Username cannot be empty"),
    check("email").normalizeEmail().isEmail().withMessage("Invalid Email"),
    check("password").trim().not().isEmpty().withMessage("Password cannot be empty").isLength({ min: 8, max: 20 }).withMessage("Password must be 8 to 20 characters long")
]

//passing the request for the checking/validation
exports.validate = (req, res, next) => {
    const error = validationResult(req).array() //.array() to get the list of errors
    if (error.length) {
        return res.json({ error: error[0].msg })
    }

    //and if there is no error then move to next task
    next()
}
/*What is happening here?
1. We used express-validator to check for the values entered by user
2. To do so we have two functions in express-validator: check() and validationResult
3. The check function is used to specify validation and sanitation rules for incoming data.
4. The validationResult function is used to extract the validation errors generated by the check function.
5. userValidator contains validation rules for the incoming request body, we are passing this during POST on /create route
6. validate is a middleware that is presumably responsible for running the validation and collecting any errors.
7. Inside validate function: 
    a. We store the result of validationResult in form of array, 
    b. We check if the array is not empty, i.e. if errors exists
    c. error array looks like this: 
    [
  {
    type: 'field',
    value: '@',
    msg: 'Invalid Email',
    path: 'email',
    location: 'body'
  }
]
    d. If error exists then we send a response of the msg. We need to set a key 'error:' so as to pass the json object
    e. response is returned and we dont execute next(), if there was no error then we would have moved ahead by executing next()
    f. next() is used commonly in middlewares
*/

//we will use this passwordValidator during reseting the password
exports.passwordValidator = [
    check("newPassword").trim().not().isEmpty().withMessage("Password cannot be empty").isLength({ min: 8, max: 20 }).withMessage("Password must be 8 to 20 characters long")
]